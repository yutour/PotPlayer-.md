---
title: "Linux 常用操作"
---

# 🚀 Bash 的标准输入输出

- **名词**

| 名称               | 解释             |                |
| :----------------- | :--------------- | :------------- |
| 标准输入（stdin）  | 键盘上的输入     | 文件描述符-->0 |
| 标准输出（stdout） | 屏幕上正确的输出 | 文件描述符-->1 |
| 标准错误（stderr） | 屏幕上错误的输出 | 文件描述符-->2 |

- **相关符号**

| 符号 | 含义                                                                  |
| :--- | :-------------------------------------------------------------------- |
| `>`  | 标准输出重定向，覆盖重定向，1>或>：标准输出重定向，2>：标准错误重定向 |
| `>>` | 重定向追加，1>>：标准输出追加，2>>：标准错误追加                      |
| `<`  | 标准输入                                                              |
| `&>` | 标准输出和标准错误都重定向                                            |

- **举例说明**

1. 环境准备

   ```bash
   # 编写简单脚本
   # 创建 1.sh 脚本文件
   echo -e 'hostname\nhello' > 1.sh
   # 查看脚本内容，确认创建成功
   cat 1.sh
   # 给 1.sh 脚本文件增加可执行权限
   chmod +x 1.sh
   # 执行该脚本（会有错误，提示 hello 命令未找到）
   ./1.sh
   ```

2. 需求 1：
   将标准输出（屏幕上的正确结果）重定向到 a.log 文件中

   ```bash
   ./1.sh > a.log
   # 或
   ./1.sh 1> a.log
   ```

3. 需求 2：
   将标准错误（屏幕上的错误结果）重定向到 a.log 文件中

   ```bash
   ./1.sh 2> a.log
   ```

4. 需求 3：

   - 把标准输出重定向到黑洞

     ```bash
     ./1.sh > /dev/null
     ```

   - 将标准错误重定向到标准输出，把标准输出重定向到黑洞，都进黑洞了

     ```bash
     ./1.sh > /dev/null 2>&1
     # 相当于
     ./1.sh &> /dev/null
     ```

5. 需求 4：

   - 将标准输出和标准错误一起重定向到 a.log 文件中

     ```bash
     ./1.sh &> a.log
     ```

   - 将标准输出追加重定向

     ```bash
     ./1.sh >> a.log
     ```

   - 将标准错误追加重定向

     ```bash
     ./1.sh 2>> a.log
     ```

   - 将标准输出和标准错误一起追加重定向

     ```bash
     ./1.sh &>> a.log
     ```

# 🚀 `echo` 命令

echo 会将输入的字符串送往标准输出，并在最后加上换行符，可以理解为打印字符串,
可以结合覆盖重定向和追加重定向一起使用

常见选项：

- `-n` : 不输出最后的换行符 "\n"
- `-e` : 解释转义字符

- **`echo` 举例说明**

```bash
# 打印 hello world
echo hello world
# 打印 aaa，不换行
echo -n aaa
# 将 hello 覆盖重定向到 file1 文件中
echo hello > file1
# 将 Linux 追加重定向到 file1 文件中
echo Linux >> file1
# 打印 hello 换行 world，使用单引号或双引号都可以
echo -e "hello\nworld"
# 或
echo -e 'hello\nworld'
# 将 hello 换行 world 追加重定向到 file1 文件中
echo -e "hello\nworld" >> file1
```

# 🚀 获取命令帮助

## ✈️ 获取简单帮助（help）

1. 内部命令（zsh 没有 help 命令，有 run-help，其实是软连接到 man 命令，需要在 bash 中使用 help 命令）
   `help 命令`
2. 外部命令
   `命令 --help`
3. 判断一个命令时内部命令还是外部命令
   `type 命令`

## ✈️ 获取详细帮助（man）

`man [章节数字] 命令`

> 章节数字含义：
>
> | 章节数字 | 含义                                    | 中文含义           |
> | :------- | :-------------------------------------- | :----------------- |
> | 1        | User Commands                           | 所有用户使用的命令 |
> | 2        | Systm Calls                             | 系统调用           |
> | 3        | C Library Functions                     | 函数库             |
> | 4        | Devices and Special Files               | 设备与特殊文件     |
> | 5        | File Formats and Conventions            | 文档格式说明       |
> | 6        | Games et. Al.                           | 游戏               |
> | 7        | Miscellanea                             | 杂项               |
> | 8        | System Administration tools and Deamons | 系统管理员命令     |
> | 9        | Kernel routines [Non standard]          | 内核例程【非标准】 |

## ✈️ 查看命令或软件的官方文档

# 🚀 文件管理与操作

## ✈️ 判断文件类型（`file` 命令）

**使用 `file` 命令探测文件或目录的类类型。**

例如：

```bash
# 字符设备
file /dev/tty1
# 字符设备
file/dev/pts/0
# 块设备
file /dev/nvme0n1
# 软链接文件
file /usr/bin/sh
# 目录文件
file /dev/pts
# 文本文件
file /etc/fstab
```

> **/dev/pts/** 目录下为当前已激活终端的保存位置，里面的文件个数会动态变化

## ✈️ 列出目录内容（`ls` 命令）

**常见选项：**

- `-a` : all，查看目录下的所有文件，包括隐藏文件
- `-d` : directory，只列出目录名，不列出其他内容
- `-h` : human，以人性化的方式显示
- `-i` : inode，显示文件的 inode 号（索引号）
- `-l` : long，长列表显示
- `-m` : comma，用逗号分隔显示内容
- `-r` : reverse，逆序排列
- `-R` : revursive，递归列出目录中的内容
- `-S` : Size，按文件大小排序
- `-t` : time，按修改时间排列

**`ll` 或 `ls -l` 显示的文件类型信息：**

| 文件               | 描述                                                                   |
| :----------------- | :--------------------------------------------------------------------- |
| 字符设备（c）      | 所有输入输出设备，如：键盘、鼠标、显示器、打印机等                     |
| 块设备（b）        | 所有存储设备，如：软盘、磁盘、光盘、U 盘、磁带、光驱等                 |
| 软链接文件（l）    | 类似于 Windows 下的快捷方式                                            |
| 目录文件（d）      | 相当于 Windows 下的文件夹                                              |
| 普通文件（f 或 -） | 类似 Windows 下记事本、word 等，可以使用相关命令进行编辑、查看文件内容 |
| 管道文件（p）      | 简单理解为程序或进程之间通讯的一种方式                                 |
| 套接字文件（s）    | 简单理解为程序或进程之间通讯的一种方式                                 |

## ✈️ 创建目录（`mkdir` 命令）

**创建目录。**

例如：

```bash
# 进入用户目录
cd ~
# 在用户目录下创建 dir1 目录
mkdir ./dir1
# 在用户目录下创建 dir2 目录
mkdir dir2
# 在用户目录下创建 dir3 和 dir4 目录
mkdir ./dir3 dir4
# 在用户目录下创建 dir5 目录，同时在 /tmp 目录下创建 dir6 目录
mkdir dir5 /tmp/dir6
# 级联创建目录
mkdir -p dira/dirb/dirc
```

## ✈️ 创建文件（`touch` 命令）

> 如果文件不存在为创建文件，
> 如果文件存在则为修改文件的时间戳（只能修改访问时间（Access）和修改时间（Modify））
>
> **Linux 下文件的命名规则：**
>
> > - 文件名严格区分大小写
> > - 文件名不能包含特殊符号（如：`/` 或 `*` 等）
> > - 文件名最多可有 255 个字符

**创建文件。**

例一：（需使用 root 用户操作）

```bash
# 删除 /tmp/ 目录下的所有文件
rm -rf /tmp/*
# 在 /tmp 目录下创建 file1 文件
touch /tmp/file1
# 在 /tmp 目录下创建 file2 和 file3 文件
touch /tmp/file2 /tmp/file3
```

例二：

```bash
# 进入用户目录
cd
# 在用户目录下创建 fileA 文件
touch fileA
# 在用户目录下创建 fileB 和 fileC 文件
touch fileB fileC
```

**修改文件的时间戳。**

> 从 RHEL6 开始 relatime，atime 延迟修改，必须满足其中一个条件：
>
> - 自上次 atime 修改后，以达到 86400 秒
> - 发生写操作时

```bash
# 查看文件的详细属性信息，包括详细时间戳信息
# Access : 最近访问时间
# Modify : 最近修改（内容）
# Change : 最近改动（属性：名称、大小、权限等，Modify 会带动 Change 一起改变）
# Birth : 创建时间
stat fileA
# ls -l 查看的是文件的修改时间，即 Modify
ls -l fileA
# 修改 Access 时间（-a : 修改 Access 时间，-t : 时间（年月日时分 yyyyMMddhhmm））
touch -a file1 -t "202010101112"
# 修改 Modify 时间（-m : 修改 Modify 时间，-t : 时间（年月日时分 yyyyMMddhhmm））
# 不会改变 Change 时间，用 ls -l 查看不会显示时分时间，而是显示年份
touch -m file1 -t "202010100912"
# 同时修改 Access 和 Modify 日期（-d : 日期（年月日 yyyyMMdd））
# 时间为 00:00:00
touch -d "20180912" file1
# 同时修改 Access 和 Modify 时间（-d : 时间（时:分:秒 hh:mm:ss））
# 日期为当前计算机日期
touch -d "11:11:11" file1
```

```asdf

```

## ✈️ 查看文件内容

- **`cat`** : 一般查看小文件，从第一行到最后一行列出来
  - 常见选项：
    - `-n` : 显示行号
    - `-A` : 显示控制字符，如换行符、制表符等（）
- **`tac`** : 一般查看小文件，从最后一行到第一行列出
- **`more`** 和 **`less`** : 一般查看大文件，q 退出查看，可以搜索，建议 less 命令
- **`head`** : 默认查看文件前 10 行，`head -n 15` 或 `head -15` 表示查看前 15 行
- **`tail`** : 默认查看文件后 10 行，`tail -n 15` 或 `tail -15` 表示查看后 15 行，`-f` 表示动态查看
- **`ldd`** : 一般用来查看二进制的命令文件

例如：

```bash
# 查看 /etc/profile 文件内容
cat /etc/profile
# 查看 /etc/profile 文件内容，并显示行号
cat -n /etc/profile
# 查看 /etc/profile 文件内容，倒序打印
tac /etc/profile
# 查看 /etc/profile 文件内容的前 5 行
head -5 /etc/profile
# 查看 /etc/profile 文件内容的后 5 行
tail -5 /etc/profile
# 查看 /etc/profile 文件内容（大文件）
less /etc/profile
# 查看 mkdir 命令文件（二进制）的内容
ldd /usr/bin/mkdir
```

## ✈️ 本地拷贝文件（`cp` 命令）

- 语法

  `cp [选项] 需要拷贝的文件 拷贝到哪里去`

- 常用选项

  | 选项 | 含义                                 |
  | :--: | :----------------------------------- |
  | `-r` | 递归拷贝目录                         |
  | `-v` | 显示拷贝过程信息                     |
  | `-p` | 文件属性信息一起拷贝                 |
  | `-a` | 递归拷贝文件，包括目录及文件属性信息 |

例如：

```bash
# 进入用户目录
cd
# 拷贝 fileA 到 dir1 目录下
cp fileA dir1
# 拷贝 fileA 到 dir1 目录下，并重命名拷贝后的文件为 test1
cp fileA dir1/testA
# 递归拷贝 dira 目录到目录 dir1 下
cp -r dira dir1
# 递归拷贝 dira 目录到目录 dir1 下，并重命名拷贝后的目录为 testDIR
cp -r dira dir1/testDIR
```

## ✈️ 移动或重命名文件（`mv` 命令）

- 移动文件（不同路径下）
  `mv 需要移动的文件 移动到新的路径下`
- 重命名文件（相同路径）
  `mv 原文件名 新文件名`

> 移动时可以同时进行重命名

例如：

```bash
# 进入用户目录
cd
# 移动 fileC 文件到 dir1 目录下
mv fileC dir1
# 重命名 fileB 文件为 fileX
mv fileB fileX
# 重命名 dira 目录为 dirX
mv dira dirX
# 移动 dirX 目录到 dir1 目录下
mv dirX dir1
# 移动 dir1/dirX 目录到 ~ 目录下，同时重命名为 dirA
mv dir1/dirX ~/dirA
```

## ✈️ 删除文件（`rm` 命令）

> oh-my-zsh 默认没有删除提示

**常用选项：**

- `-r` : 递归删除，一般用于删除目录
- `-f` : 直接删除，不提示

例如：

```bash
# 进入用户目录
cd
# 删除当前目录下的 file1 文件，带提示
rm file1
# 递归删除当前目录下的 dir1 目录，有提示
rm -r dir1
# 强制删除 fileX 文件，无提示，直接删除
rm -f fileX
# 强制递归删除 dirX 目录，无提示，直接删除
rm -rf dirX
```

# 🚀 Linux 下的文件查找命令

## ✈️ 命令查找（`which` 和 `whereis` 命令）

- `which` : 找出命令的绝对路径
- `whereis` : 找出命令的路径以及文档手册信息

例如：

```bash
# 打印 mkdir 命令所在的路径
which mkdir
# 打印 mkdir 命令所在的路径和文档手册信息
whereis mkdir
```

## ✈️ 文件查找（`find` 命令）

`find` : 精确查找，磁盘搜索，IO 读写，cpu 开销大

1. 用法一：输出结果到屏幕
   根据需求将查找结果直接输出到屏幕

   用法：**`find 查找路径 选项 关键字`**

   | 常见选项 | 含义                     | 备注                                           |
   | :------- | :----------------------- | :--------------------------------------------- |
   | `-name`  | 按照文件名查找           |                                                |
   | `-iname` | 按照文件名忽略大小写查找 |                                                |
   | `-size`  | 按照文件大小查找         | +1M : 大于 1M，-1M : 小于 1M，1M : 等于 1M     |
   | `-type`  | 按照文件类型查找         |                                                |
   | `-mtime` | 按照文件修改时间查找     | -n : n 天以内，+n : n 天以前，n : 往前数第二天 |
   | `-atime` | 按照文件访问时间查找     |                                                |
   | `-ctime` | 按照文件创建时间查找     |                                                |
   | `-perm`  | 按照文件权限查找         |                                                |

   > **特别注意：**
   >
   > - `-size`
   >
   >   - 按照文件大小查找时，经常不能得到我们想要的结果，因为 find
   >     命令会对容量按单位递进缩小查找，（G - M - k - w - c - b）
   >
   >   - `find . -type f -size -2M` 查找当前路径下小于 2M 的文件，
   >     它会先找单位为 M 且小于 2M 的文件，单位为 M 的文件找完后会找单位为 k
   >     且小于 2k 的文件，如果一个文件为 5k，它是不会显示的，然后继续往下找单位为
   >     w 且小于 2w 的文件，类推直到单位为 b 的文件，如果要找到 5k 的文件，需要使用
   >     `find . -type f -size -2048k` 来查找
   >
   >   - 使用时尽可能使用较小的单位较大的数字
   >
   >   - 说明见 `man find` 手册的 `-size` 部分
   >
   > - `-mtime`
   >   - `+2` : 查找两天以前修改过的文件，假如今天为 15 号，会查找 13
   >     号以前修改过的文件，不包括 13 号修改过的文件
   >   - `-2` : 查找两天以内修改过的文件，假如今天为 15 号，会查找 13
   >     号以后修改的文件，不包括 13 号修改过的文件，即 14 和 15 号修改过的文件
   >   - `2` : 查找往前数第二天修改过的文件，假如今天为 15 号，会查找 13
   >     号这天修改过的文件
   >   - `-daystart` : 放在 `-xtime` 之前，表示按 24
   >     小时切割时间，尽量使用此参数。
   >     例如：`find ./ -type f -daystart -mtime 2`

   例如：

   ```bash
   # 一：准备
   # 进入用户目录
   cd
   # 创建 ~/dirA/dirB 目录
   mkdir -p dirA/dirB
   # 创建文件 ~/dirA/fileA 和 ~/dirA/fileB
   touch ./dirA/fileA ./dirA/fileB
   # 将文件 ~/dirA/fileA 复制为 ~/dirA/dirB/fileC 和 ~/dirA/dirB/fileD
   cp ./dirA/fileA ./dirA/dirB/fileC
   cp ./dirA/fileA ./dirA/dirB/fileD

   # 二：根据文件名查找
   # 在 ~/dirA 目录下查找 fileC 文件（区分大小写）
   find ~/dirA -name "fileC"
   # 在 ~/dirA 目录下查找 fileC 不区分大小写）
   find ~/dirA -name "filec"
   # 在 /etc 目录下查找后缀名为 conf 的文件
   find /etc -name "*.conf"

   # 三：根据文件类型查找
   # 在 /usr/bin 目录下查找所有的链接文件
   find /usr/bin -type l
   # 在 /dev 目录下查找所有的设备块
   find /dev -type b
   # 进入 ~/dirA 目录
   cd ~/dirA
   # 在当前路径下查找所有的目录
   find . -type d
   # 在当前路径下查找所有的文件
   find . -type f

   # 四：根据文件大小查找（查看上方的 特别注意）
   # 在当前路径下查找文件尺寸大于 1M 的文件
   find . -type f -size +1M
   # 在当前路径下查找文件尺寸小于 1M 的文件
   find . -type f -size -1M
   # 在当前路径下查找文件尺寸小于 1024k 的文件
   find . -type f -size -1024k
   # 在当前路径下查找文件尺寸为 9M 的文件
   find . -type f -size 9M

   # 五：根据文件属性查找（权限、创建者和所属组）
   # 在当前路径下查找文件所有者为 xxx 所属组为 yyy 的文件
   find . -user xxx -group yyy -type f
   # 在当前路径下查找文件权限为 644 的文件
   find . -type f -perm 644
   # 在当前路径下查找 2 天以前修改过的文件（查看上方的 特别注意）
   find ./ -type f -mtime +2
   # 在当前路径下查找 2 天以内修改过的文件（查看上方的 特别注意）
   find ./ -type f -mtime -2
   # 在当前路径下查找之前第二天修改过的文件（查看上方的 特别注意）
   find ./ -type f -mtime 2
   # 尽量使用 -daystart 参数（查看上方的 特别注意）
   find ./ -type f -daystart -mtime +2
   find ./ -type f -daystart -mtime -2
   find ./ -type f -daystart -mtime 2
   ```

2. 对查找结果执行命令
   根据需求对查找出的结果执行某个动作（命令）

   用法：**`find 路径 选项 关键字 动作`**

   | 常见动作  | 说明                                            |
   | :-------- | :---------------------------------------------- |
   | `-exec`   | 对查找结果直接执行该参数后的 shell 命令         |
   | `-ok`     | 对查找结果进行询问式的执行该参数后的 shell 命令 |
   | `-delete` | 删除查找到的文件                                |
   | `-ls`     | 显示查找结果的详细信息                          |
   | `-print`  | 打印查找的结果（默认）                          |

   > **注意：**
   >
   > - `-exec` 或 `-ok` 后面写完命令必须以空格反斜杠分号结尾（**`空格\;`**）
   > - `{}` 表示 find 命令所查找出的内容

   例如：

   ```bash
   # 在 /tmp 目录下创建 dirX 目录
   mkdir /tmp/dirX
   # 查找当前路径下的所有文件，并显示详细信息
   find ./ -type f -ls
   # 查找当前路径下两天前修改过的文件，并删除
   find ./ -type f -mtime +2 -delete
   # 查找当前路径下的所有文件，并复制到 /tmp/dirX 目录下（不询问）
   find ./ -type f -exec cp {} /tmp/dirX \;
   # 查找当前路径下的所有文件，并复制到 /tmp/dirX 目录下（询问）
   find ./ -type f -ok cp {} /tmp/dirX \;
   # 删除 /tmp/dirX 目录
   rm -r /tmp/dirX
   ```

# 🚀 Linux 下的文件压缩工具

## ✈️ 常见的压缩和解压缩工具

| 压缩工具 | 说明                                                             | 对应的解压缩工具 |
| :------: | :--------------------------------------------------------------- | :--------------- |
|   zip    | 兼容类 UNIX 与 Windows，可以压缩多个文件或目录                   | unzip            |
|   gzip   | 压缩单个文件，压缩率相对较低，cpu 开销相对较低                   | gunzip           |
|  bzip2   | 压缩单个文件，压缩率相对较高，cpu 开销相对较高                   | bunzip2          |
|    xz    | 压缩单个文件，压缩率高，压缩时间相对较长，加压速度块，cpu 开销高 | unxz             |

> `gzip bzip2 xz` 只能压缩单个文件，当命令作用在一个目录上时，
> 那么目录中的所有文件都会被压缩为一个一个的压缩包

## ✈️ 常见压缩、解压缩工具的用法

- **zip**

  会改变文件的属性

  - 压缩：
    `zip 压缩后的文件名 需要压缩的文件名`

    - 选项
      - `-r` : 递归压缩，压缩目录

    > **注意：** zip 压缩默认压缩后的文件格式就是 `.zip`，
    > 当然也可以手动添加后缀 `.zip`，一般都加上

  - 解压缩：（会自动创建顶层目录）
    `-d` : 指定解压路径

- **gzip**

  - 压缩：
    `gzip 需要压缩的单个文件`

    被压缩的文件会变成压缩文件，源文件没了

    - 选项：
      - `-d` : 解压缩
      - `-r` : 递归压缩（目录）

  - 解压缩：
    `gunzip 需要解压的文件` 或 `gzip -d 需要解压的文件`

    被解压缩的文件会变成文件，压缩文件没了

    `gunzip file*` : 一次解压多个文件，`*` 代表通配符，`file *` 表示以
    `file` 开头的所有文件

- **bzip2**

  - 压缩：
    `bzip2 需要压缩的文件`

    被压缩的文件会变成压缩文件，源文件没了

    被解压缩的文件会变成文件，压缩文件没了

    - 选项：
      `-d` : 解压缩

- **xz**

  - 选项：
    - `-z` : 压缩，默认
    - `-d` : 解压缩，或使用 `unxz`
  - 压缩：
    `xz 需要压缩的文件`

    被压缩的文件会变成压缩文件，源文件没了

  - 解压缩：
    `unxz : 需要解压的文件` 或 `xz -d 需要解压的文件`

    被解压缩的文件会变成文件，压缩文件没了

# 🚀 Linux 的打打包工具（`tar` 命令）

`tar` 命令：可以将多个文件打包并压缩（可选）成一个文件，不会改变文件的属性，很常用。

- **用法**

  `tar 选项 打包后的文件名 需要打包的文件`

- **常用选项**

  | 常用选项 | 说明                    |
  | :------: | :---------------------- |
  |   `-c`   | 创建 tar 包（打包）     |
  |   `-z`   | 调用 gzip 工具压缩      |
  |   `-j`   | 调用 bzip2 工具压缩     |
  |   `-J`   | 调用 xz 工具压缩        |
  |   `-v`   | 显示详细信息            |
  |   `-f`   | 指定包名                |
  |   `-x`   | 解压                    |
  |   `-C`   | 指定解压路径            |
  |   `-t`   | 列出或查看 tar 包的内容 |
  |   `-r`   | 往 tar 包里追加文件     |

- **使用注意：**

  1. 上面列出选项前面的横杠 `-` 可以省略
  2. 如果已经将文件打包并压缩，那么就不能追加文件了，如果只是打包了，
     没有压缩，那么可以追加文件
  3. 参数顺序需要注意，最好把 `-f` 参数放到所有参数后面
  4. 当出现提示 **tar: Removing leading \`/' from member names** 时，
     加一个大写的`P` 参数可以解决问题，放到 `f` 前

- **示例：**

  ```bash
  # 一：准备
  # 进入用户目录
  cd
  # 创建目录 ~/dirA/dirB ~/dirC ~/dirD
  mkdir -p dirA/dirB dirC dirD
  # 创建文件 ~/dirA/fileA、~/dirA/fileB、~/dirA/dirB/fileC、~/dirA/dirB/fileD
  touch dirA/fileA dirA/fileB dirA/dirB/fileC dirA/dirB/fileD
  # 创建文件 ~/dirC/fileE ~/dirC/fileF
  touch dirC/fileE dirC/fileF

  # 二：打包、追加、查看
  # 将 ~/dirA 目录和 /etc/hosts 文件打包到 ~/ 目录下的 dabao.tar 文件
  # 下面一句命令会有错误提示，查看上方的 使用注意
  tar -cvf dabao.tar ./dirA /etc/hosts
  # 将 /etc/locale.conf 文件追加到 dabao.tar
  tar -Pf dabao.tar -r /etc/locale.conf
  # 查看打包后的文件内容
  tar -tf dabao.tar

  # 三：打包并压缩
  # 将 ~/dirC 目录和 /etc/locale.conf 文件打包并压缩到 ~/bak_files.tar.gz 文件
  # 下面一句命令会有错误提示，查看上方的 使用注意
  tar -cvzf ~/bak_files.tar.gz ~/dirC /etc/locale.conf

  # 四：解压
  # 解压 bak_files.tar.gz 到当前路径
  # 注意不会自动建立顶层目录，最好建一个空目录将 bak_files.tar.gz 放进去，再解压
  tar -xf bak_files.tar.gz
  # 解压 bak_files.tar.gz 到 ~/dirD/ 下
  # 注意指定的目录必须存在，不会自动创建，要先创建再使用
  tar -xf bak_files.tar.gz -C ~/dirD/
  ```

# 🚀 日期相关命令（`date` 和 `cal`）

## ✈️ `date` 命令

`date` : 打印或设置当前系统的日期和时间

- **打印日期或时间**

  ```bash
  # 打印当前日期或时间
  date            # Thu Dec  9 17:53:57 CST 2021
  date +%D        # 12/09/21
  date +%F        # 2021-12-09
  date +%Y-%m-%d  # 2021-12-09
  date +%Y_%m_%d  # 2021_12_09
  date +%T        # 17:55:59
  date +%x        # 12/09/2021
  date +'%F %x'   # 2021-12-09 12/09/2021
  date +%c        # Thu 09 Dec 2021 05:56:51 PM CST

  # 打印非当前日期或时间
  date -d '+3days' +%F     # 2021-12-12
  date -d '-3days' +%F     # 2021-12-06
  date -d '3days' +%F      # 2021-12-12
  date -d '3days ago' +%F  # 2021-12-06
  date --date='30days' +%F # 2022-01-08
  ```

- **设置系统日期或时间**

> RHEL8 开始设置日期为之前日期的话，过一会又会变为当前日期

- 选项：`-s` 设置当前系统时间，只有 root 权限才能设置，其他只能查看

  ```bash
  # 日期设置成 20100523，这样会把具体时间设置成空 00:00:00
  date -s "20200523"
  # 时间设置为 10:11:12，这样只会设置时间，日期不变
  date -s "10:11:12"
  # 以下几种写法都可以设置全部时间，效果一样
  date -s "01:01:01 2020-05-2"
  date -s "01:01:01 20200523"
  date -s "2020-05-23 01:01:01"
  date -s "20200523 01:01:01"
  ```

- **设置系统时间同步硬件时间**

  `hwclock` : 查看并且设置硬件时间，需要在 root 下使用

  - 选项：
    - `-s` 或 `--hctosys` : 设置系统时间为硬件时间
    - `-w` 或 `--systohc` : 设置硬件时间为系统时间
    - `-l` 或 `--localtime` : 查看本地的硬件时间

  ```bash
  hwclock --hctosys
  hwclock
  date
  date -s "20221010 12:12:12"
  date
  hwclock
  hwclock --systohc
  hwclock
  ```

  `timedatectl -h` : 设置和查看系统的时间和日期（设置时区以及开启或关闭 ntp 服务）

- **应用示例**

  ```bash
  # 创建目录和文件，以当前系统日期命名
  # 1. $() : 括号里面的命令会优先执行
  # 2. `` : 反引号里面的命令优先执行
  # 上面两种都优先执行都可以，建议使用第一种，在嵌套使用的话第二种会混淆
  mkdir $(date +%F)
  touch $(date -d '+3days' +%Y%m%d).log
  ```

## ✈️ `cal` 命令

- `cal` : 查看日历

  ```bash
  # 直接输出当前月份的日历
  cal
  # 或
  cal -1
  # 输出上一个月 + 本月 + 下个月的日历
  cal -3
  # 输出某一个年份的日历
  cal -y 2021
  ```

# 🚀 Linux 下的用户管理

## ✈️ 用户的概念和作用

**用户**指的是 Linux 操作系统中用户管理系统或服务的人

- 管理系统到底在管理什么？
  Linux 下一切皆文件，所以用户管理的是相应的文件
- 如何管理文件呢？
  1. 文件的基本管理，比如文件的创建、删除、复制、查找、打包、压缩等，文件权限的增加、减少等
  2. 文件的高级管理，比如程序文件的安装、卸载、配置等，终极目标是对外提供稳定的服务

## ✈️ 用户的分类

### 🚄 超级用户

- 也叫管理员用户 `root`，该用户具有所有权限，UID=0 并且只能是 0

### 🚄 系统用户

- 也叫称呼用户，一般都是由程序创建的，用于运行程序或服务时需要的身份
- 默认不允许登陆系统，1 <= UID <= 499
  > **注：** Centos7/RHEL8 中，系统用户的 UID 范围为：1 <= UID <= 999

### 🚄 普通用户

- 一般由管理员创建，用于对系统进行有限的管理维护操作
- 默认可以登陆系统，500 <= UID <= 60000
  > **注：** Centos7/RHEL8 中，普通用户的 UID 范围为：1000 <= UID <= 60000
- 特别说明：
  1. 用户指的是操作系统上管理系统或服务的人，具有相关的属性信息
  2. 用户的属性信息包括但不限于：家目录、唯一身份标识（UID）、所属组（GID）等

## ✈️ 用户的基本管理

### 🚄 创建用户（`useradd`）

- **基本使用语法和选项**

  - _基本使用语法_

    `useradd [选项] 用户名`

  - _常用选项_

    | 选项 | 说明                                                               |
    | :--: | :----------------------------------------------------------------- |
    | `-u` | 指定用户的 UID，唯一标识，必须唯一                                 |
    | `-g` | 指定用户的默认组（主组）                                           |
    | `-G` | 指定用户的附加组（一个用户可以加入多个组，但默认组只有一个）       |
    | `-d` | 指定用户的家目录（每个用户都有一个自己的家目录，默认在 /home/xxx） |
    | `-s` | 指定用户默认的 shell                                               |

  - _shell（解释器）_

    ```bash
    # 查看系统支持的 shell
    cat /etc/shells
    # /bin/sh       # 软链接文件
    # /bin/bash     # 系统默认的解释器
    # /usr/bin/sh   # 软链接文件
    # /usr/bin/bash # 系统默认的解释器

    # 其他 shell
    # /sbin/nologin # 不能登陆操作系统，也叫非交互式 shell
    # /bin/dash
    # /bin/tcsh
    # /bin/csh
    ```

- **应用示例**

  - _创建默认用户_

    ```bash
    # 创建一个用户 stu1
    useradd stu1
    # 查看新用户信息
    id stu1
    # uid=1002(stu1) gid=1002(stu1) groups=1002(stu1)
    # 切换登陆到 stu1 用户
    su - stu1
    ```

    > 当使用默认设置创建一个用时候，系统会给予以下默认设置：（以 stu1 为例说明）
    >
    > 1. 用户的 UID（唯一标识）：1002（系统自动分配）
    > 2. 用户的默认组（主组） ：stu1 组，默认与用户名一致，组 ID 为 1002，默认与用户 UID 一致
    > 3. 用户的家目录 ：/home/stu1
    > 4. 拷贝相应的默认文件到用户的家目录（一般为默认的 shell 配置文件之类的）

  - _根据需求创建用户_

    ```bash
    # 示例一：创建用户 stu2，但使其不能登录操作系统
    useradd -s /sbin/nologin stu2
    # 查看新用户信息
    id stu2
    # 切换登陆到该新用户，切换登陆失败，该用户不能登录
    su - stu2

    # 示例二：创建用户 stu3，同时指定该用户的家目录为 /rhome/stu3
    # 创建 /rhome 目录
    mkdir /rhome
    # 创建用户
    useradd -d /rhome/stu3 stu3
    # 查看新用户信息
    id stu3
    # 注：指定新用户目录时，需要 /rhome 目录存在，系统会自动创建 /rhome/sut3 目录
    # 如果 /rhome 目录不存在时创建了 stu3 用户，用户依然会被创建，但登入时会提醒没有家目录
    # 可以手动创建 /rhome/stu3 目录，但是不会自动拷贝默认的配置文件，需要手动
    # 从 /etc/skel/ 目录拷贝用户基础配置文件到 /rhome/stu3/ 目录下，还要注意 目录和文件的权限
    ```

### 🚄 用户密码设置（`passwd`）

- **基础命令**

  - `passwd 用户名` : 表示给指定用户修改密码
  - `passwd 直接回车` : 表示给当前用户修改密码

    > **注：**
    >
    > - 管理员用户 root 可以给任何用户修改密码
    > - 普通用户可以自己给自己修改密码，但是密码复杂度需要符合规范

    ```bash
    # 修改 stu1 用户的密码
    passwd stu1
    # 修改用户 stu2 的密码
    # 这种方法不使用交互式修改方式也可以直接设置成功，一般用于脚本中
    echo 123|passwd --stdin stu2
    ```

- **保存用户信息和用户密码的文件**

  - 保存用户信息的文件为 `/etc/passwd`，每个用户的信息分为 7 列以冒号 `:` 分割，含义如下：

    | 列号 | 内容      | 示例       | 说明                                                 |
    | :--: | :-------- | :--------- | :--------------------------------------------------- |
    |  1   | account   | stu1       | 用户名                                               |
    |  2   | password  | x          | 密码，密码单独存放在另外一个文件中                   |
    |  3   | UID       | 1002       | 用户 ID                                              |
    |  4   | GID       | 1002       | 组 ID                                                |
    |  5   | GECOS     |            | 描述说明，用户自定义                                 |
    |  6   | directory | /home/stu1 | 用户的家目录                                         |
    |  7   | shell     | /bin/bash  | 用户默认的 shell，/sbin/nologin 表示非交互，不可登入 |

    > 使用 `man 5 passwd` 查看详细文档

  - 保存用户密码信息的文件为 `/etc/shadow`，每个用户的密码信息分为 9 列，以冒号 `:` 分割，含义如下：

    1. `login name` : 登陆的用户名
    2. `encrypted password` : 加密后的密码，`!!` 表示没有设置密码
    3. `date of last password change` : 最后一次更改密码的天数（距离 1970 年 1
       月 1 日 到现在的天数），如果为 0 则表示该用户下次登入时必须要修改密码
    4. `minimum password age` : 密码的最小生存周期;0 表示可以立刻修改密码；
       如果是 3，则表示 3 天后才能更改密码
    5. `maximum password age` : 密码的最大生存周期;如果为 30 则表示每隔 30 天需要更新一次密码
    6. `password warning period` : 密码过期前几天发出警告；7 表示过期前 7 天开始警告
    7. `password inactivity period` : 密码的宽限期；如果为 3 表示允许密码过期
       3 天，3 天内还能登录系统，但是要求修改密码。
       3 天后（密码过期 3 天后账户被封锁，需要联系管理员）
    8. `account expiration date` : 账户过期的时间，账户过期的用户不能登录；
       密码过期用户不能用原来的密码登录。从 1970 年 1 月 1 日算起。
    9. `reserved field` : 保留
       > 使用 `man 5 shadow` 查看详细文档

- **更改用户的账号信息（chage）**

  - _用法：_ `chage [选项] 用户名`
  - _选项：_

    | 选项 | 说明                                               |
    | :--- | :------------------------------------------------- |
    | `-d` | 修改用户最后一次更改密码的时间                     |
    | `-m` | 修改密码的最小存活期（几天后才能再次修改密码）     |
    | `-M` | 修改密码的最大存活期（每隔多少天需要更新一次密码） |
    | `-w` | 修改密码过期前警告（过期前几天发出警告）           |
    | `-I` | 修改允许密码过期几天                               |
    | `-E` | 修改账户过期时间                                   |
    | `-l` | 列出账户的信息                                     |

    ```bash
    # 查看用户账号的相关信息
    chage -l stu1
    # 修改用户账号的过期时间为 2019-03-10 过期
    chage -E '2019-03-10' stu1
    chage -l stu1
    # 修改用户账号的过期时间为 10 天以后
    chage -E $(date +%F -d '+10days') stu1
    # 设置用户账号在下次登入时必须修改密码
    chage -d 0 stu2
    # 查看用户账号的相关信息
    chage -l stu2
    ```

### 🚄 修改用户信息（`usermod`）

- **基本语法及选项**

  - _基本语法：_ `usermod [选项] 用户名`
  - _常用选项：_

    | 选项 | 说明                                                             |
    | :--: | :--------------------------------------------------------------- |
    | `-u` | 指定用户 UID，唯一标识，必须唯一                                 |
    | `-g` | 指定用户的默认组（主组）                                         |
    | `-G` | 指定用户的附加组（一个用户可以加入多个组，但默认组只有一个）     |
    | `-d` | 指定用户家目录（每个用户都有一个自己的家目录，默认在 /home/xxx） |
    | `-s` | 指定用户默认的 shell                                             |
    | `-m` | 移动用户家目录，和 `-d` 一起使用                                 |

- **应用示例**

  ```bash
  # 修改 stu3 用户的 UID 为 1100
  usermod -u 1100 stu3
  # 查看修改是否成功
  tail -5 /etc/passwd

  # 修改 stu2 用户的默认 shell 为可登陆系统
  # 测试 stu2 现在为不可登陆
  su - stu2
  # 修改 stu2 用户的默认 shell
  usermod -s /bin/sh stu2
  # 查看修改是否成功
  tail -5 /etc/passwd

  # 添加 stu5 用户并修改该用户的家目录
  useradd -d /rhome/stu5 stu5
  usermod -md /home/stu5 stu5
  ```

### 🚄 删除用户（`userdel`）

- **基本语法选项**
  - _基本语法：_ `userdel [选项] 用户名`
  - _常用选项：_
    - `-r` : 删除用户并且移除其家目录和邮箱
    - `-f` : 强制删除正在登入的用户
- **应用示例**

  > **注：**
  >
  > 创建完用户后，家目录默认在 `/home/用户名` 下，用户的邮箱在 `/var/spool/mail/用户名`

  ```bash
  # 删除 stu5 用户以及家目录
  userdel -r stu5
  id stu5

  # 强制删除一个正在登入的用户
  userdel -r stu2
  id stu2
  userdel -rf stu2
  id stu2

  # 只删除用户 stu1 不删除其家目录
  userdel stu1
  ```

# 🚀 Linux 下的组管理

## ✈️ 组和用户的关系

- **组的目的是为了方便管理用户**
  - 用户是操作系统上管理维护系统或服务的人
  - 组是用户的一个属性信息
  - 任何一个用户默认都会有一主组（默认组）
  - 一个用户除了主组也可以有多个其他组（附加组）
- **用户的主组和附加组到底有什么关系？**
  - 用户的主组和附加组什么关系都没有
- **主组和附加组有什么用？**
  - 组的目的是方便管理用户，用户的目的是管理操作文件，文件有权限这个属性
    - 用户要操作一些文件，文时是由用户创建的，不同用户创建的文件的属性信息是不同的
    - 文件的属性有：文件的创建者、文件的所属组、文件大小、文件时间等
    - 其中，不同用户所创建的文件的所属组就是该用户的主组（默认组）
    - A 用户的附加组有可能是其他用户的主组（权限问题查看权限部分体会组的作用）

## ✈️ 组的管理

### 🚄 创建组（`groupadd`）

- **基本语法**
  - _语法_
    - `groupadd [选项] 组名`
  - _常用选项_
    - `-g` : 指定组的 GID（编号），默认唯一
- **应用示例**

  ```bash
  # 创建一个组 admin
  groupadd admin
  # 查看组信息
  tail -l /etc/group
  #创建一个组 sysadmin，指定组的 GID 为 1111
  groupadd -g 1111 sysadmin
  # 查看组信息
  tail -l /etc/group
  ```

  > 使用 `man 5 group` 查看详细信息
  >
  > 组的信息保存在 `/etc/group` 和 `/etc/gshadow` 文件内

### 🚄 删除组（`groupdel`）

- **基本语法**
  - _语法_
    - `groupdel 组名`
- **应用示例**

  ```bash
  # 删除组 admin
  groupdel admin
  # 删除组 stu2
  groupdel stu2
  # 提示：groupdel: cannot remove the primary group of user 'stu2'
  # 上面提示信息说明不能删除属于其他用户的主组
  ```

### 🚄 组成员管理（`gpasswd`）

- **基本语法**

  - _语法_
    - `gpasswd [选项] 组名`
  - _常见选项_

    | 选项 | 说明                               |
    | :--: | :--------------------------------- |
    | `-a` | 添加用户到组                       |
    | `-d` | 从组中删除成员                     |
    | `-A` | 指定管理员                         |
    | `-M` | 指定组成员，可以批量添加用户到组中 |
    | `-r` | 删除密码                           |

  - _给组设置密码_
    - `gpasswd 组名`

- **应用示例**

  ```bash
  # 添加用户到组里
  # 创建 3 个用户：user01 user02 user03
  useradd user01
  useradd user02
  useradd user03

  # 将 user01 添加到 sysadmin 组里
  # 方法一：指定 user01 用户的附加组为 sysadmin (站在用户角度)
  usermod -G sysadmin user01
  # 方法二：使用 gpasswd 命令添加用户到组里
  # -a 选项表示往组里追加用户
  gpasswd -a user01 sysadmin

  # 设置 sysadmin 组成员为 user02,user03
  # -M 选项表示覆盖设置组成员（会覆盖原来的成员列表）
  gpasswd -M user02,user03 sysadmin

  # 删除组成员
  # 将 user03 用户从组 sysadmin 里移除
  gpasswd -d user03 sysadmin
  ```

# 🚀 Linux 下文件的权限管理

## ✈️ 权限概述

- **什么是权限**

  - 在计算机系统中，权限是指某个计算机用户具有使用软件资源的权利
  - _计算机资源分为哪两部分？_
    - 硬件资源：硬盘、CPU、内存、网卡等物理硬件资源
    - 软件资源：操作系统（特殊的软件）、应用程序。
      只要不启动，这些软件就是一堆静态的文件，并且静静的躺在我们的计算磁盘中。
      在 Linux 系统中，一切皆文件，这里的软件资源就是文件资源

  > 这里的权限指的就是：文件资源所拥有的相关权限，即文件权限

- **权限设置的目的**
  - 目的是让某个用户（Linux 操作系统中的用户）有权利操作文件
- **文件权限的分类**

  - _普通权限_
    - 用户正常情况去操作文件所具有的权限
  - _高级权限_
    - 用户对某个文件操作有特殊需求，而普通权限不能满足，需要给文件设置高级权限
  - _默认权限_
    - 用户在系统中创建一个文件，该文件默认都会有一个权限，该权限是默认具有的

  > 权限是设置在文件上的，而不是用户，设置权限的目的是让相应的用户可以去操作相应的文件

## ✈️ 普通权限

### 🚄 理解普通权限 `rwx` 的含义

- **读取权限 `r`（read）**
  - _针对目录_
    - 一个目录拥有 `r` 权限，说明可以查看该目录里的内容（使用 `ls` 命令列出）
  - _针对普通文件_
    - 一个普通文件拥有 `r` 权限，说明可以查看该文件的内容（使用
      `cat head tail less more` 等命令查看）
  - _读权限 `r` (read) 用数字表示是 `4`_
- **写入权限 `w`（write）**
  - _针对目录_
    - 一个目录拥有 `w` 权限，说明可以在该目录里创建、删除、重命名等操作（使用
      `mkdir touch mv rm` 等命令）
  - _针对普通文件_
    - 一个普通文件拥有 `w` 权限，说明可以修改该文件的内容（使用 `vi vim` 等命令进行编辑）
  - _写权限 `w` (write) 用数字表示是 `2`_
- **执行权限 `x`（execute）**
  - _针对目录_
    - 一个目录拥有 `x` 权限，说明可以进入或切换到该目录里（使用 `cd` 命令）
  - _针对普通文件_
    - 一个普通文件用于 `x` 权限，说明可以执行该文件（一般程序文件、脚本文件、命令都需要执行权限）
  - _执行权限 `x` (execute) 用数字表示是 `1`_
- **没有权限 `-`（横杠）**
  - _没有任何权限用横杠 `-` 表示，用数字表示是 `0`_

### 🚄 理解 UGO 的含义

- **UGO 指的是什么**

  UGO 指的是用户身份，每个字母代表不同的用户身份

  - _U (the user who owns it)_
    - 文件的拥有者（owner）或者创建者
  - _G (other users in the file's group)_
    - 在文件的所属组（默认是创建文件的用户的主组）里的用户
  - _O (other users not in the file's group)_
    - 既不是文件的创建者，也不再文件属组里的用户，成为其他人

  > 除了上面 UGO 以外，还有一个字母 `a` (all users)，表示所有用户，包含 UGO

- **如何判断不同身份的用户对文件的权限**

  ```bash
  # 查看文件详细信息，包含权限信息
  ls -l
  ```

  - _权限的表示格式共有 10 个位置：**0123456789**_

    - 第 `0` 位表示文件类型，总共有 7 种文件类型，如下表：

      | 类型符号 | 类型说明 |
      | :------: | :------- |
      |   `d`    | 目录     |
      |   `l`    | 软链接   |
      |   `b`    | 块设备   |
      |   `c`    | 字符设备 |
      |   `s`    | socket   |
      |   `p`    | 管道     |
      |   `-`    | 普通文件 |

    - 第 `123` 位表示文件拥有者的权限
    - 第 `456` 位表示文件所属组用户的权限
    - 第 `789` 位表示其他用户的权限

### 🚄 修改文件的普通权限（`chmod`）

- **`chmod` 命令用法**

  - _语法：_ `chmod [选项] 模式 文件名`
  - _常见选项：_ `-R, --recursive` : 递归更改目录和目录里文件的权限

- **应用示例**

  - _通过字母形式更改文件权限_

    - `u` : 表示文件拥有者
    - `g` : 表示文件属组里的用户
    - `o` : 表示其他人，既不是文件的创建者，也不在文件属组里
    - `a` : 表示所有人

    ```bash
    # 准备
    # 切换到管理员用户
    su
    # 进入 /tmp 目录
    cd /tmp/
    # 创建目录 /tmp/dir 和 /tmp/dir/dirA
    mkdir /tmp/dir /tmp/dir/dirA
    # 在 /tmp/dir/dirA/ 目录下创建 5 个文件
    touch /tmp/dir/dirA/file{1..5}
    # 在 /tmp/dir/ 目录下创建 3 个文件
    touch /tmp/dir/test{1..3}
    # 递归查看 /tmp/dir/ 目录下的文件和目录详情
    ll /tmp/dir -R

    # 用字母的形式修改文件权限
    # 进入 /tmp/dir/ 目录
    cd /tmp/dir/
    # 查看 test1 文件的详情
    ll test1
    # 为 test1 文件所属用户添加 test1 文件的可执行权限
    chmod u+x test1
    # 查看 test1 文件的详情
    ll test1
    # 为 test1 文件所属组添加 test1 文件的写入权限
    chmod g+w test1
    # 查看 test1 文件的详情
    ll test1
    # 为其他用户删除 test1 文件的读取权限
    chmod o-r test1
    # 查看 test1 文件的详情
    ll test1
    # 查看 test2 文件的详情
    ll test2
    # 为所有用户和组添加 test2 文件的可执行权限
    chmod a+x test2
    # 查看 test2 文件的详情
    ll test2
    # 查看 test3 文件的详情
    ll test3
    # 为 test3 文件的所属用户添加可执行权限，所属组添加写入权限，其他用户删除读取权限
    chmod u+x,g+w,o-r test3
    # 查看 test3 文件的详情
    ll test3
    # 将 test3 文件的所属用户权限设置为读和写，所属组权限设置为读和执行，其他用户添加读取权限
    chmod u=rw,g=rx,o+r test3
    # 查看 test3 文件的详情
    ll test3

    # 修改目录权限
    # 查看 /tmp/dir/dirA 目录本身的详情
    ll -d dirA
    # 查看 /tmp/dir/dirA/ 目录下所有文件的详情
    ll dirA
    # 1. 只修改目录本身的权限
    # 为 /tmp/dir/dirA 目录所属组添加写入权限
    chmod g+w dirA
    # 查看 /tmp/dir/dirA 目录本身的详情
    ll -d dirA
    # 查看 /tmp/dir/dirA/ 目录下所有文件的详情
    ll dirA
    # 可以发现，目录下面文件的权限并没有修改
    # 2. 修改目录以及目录里所有文件的权限（递归修改），使用 -R 参数
    # 为 /tmp/dir/dirA 目录及目录下所有文件添加其他用户写入权限
    chmod -R o+w dirA
    # 查看 /tmp/dir/dirA 目录本身的详情
    ll -d dirA
    # 查看 /tmp/dir/dirA/ 目录下所有文件的详情
    ll dirA
    ```

  - _通过数字形式更改文件权限_

    - 字母和数字权限对应关系

      |               |               |
      | :-----------: | :-----------: |
      |      `r`      |      `4`      |
      |      `w`      |      `2`      |
      |      `x`      |      `1`      |
      |      `-`      |      `0`      |
      | `rw- r-x r--` |     `654`     |
      | `rwx rw- ---` |     `760`     |
      |     `755`     | `rwx r-x r-x` |
      |     `644`     | `rw- r-- r--` |

    ```bash
    # 使用数字设置 file1 文件的权限
    chmod 644 file1   # rw-r--r--
    # 使用数字设置 file2 文件的权限
    chmod 700 file2   # rwx------
    # 使用数字递归设置 dirA 目录和目录下所有文件的权限
    chmod -R 755 dirA # rwxr-xr-x
    ```

## ✈️ 文件的属主和属组

### 🚄 如何查看文件的属主和属组

- `drwxr-xr-x. 2 root root 2196 Feb 28 12:12 dirA`
  - 第一个 `root` 就是属主
  - 第二个 `root` 就是属组

### 🚄 如何修改文件的属主和属组

- **`chown` 命令**

  - `chown` 命令既可以修改文件的属主，也可以修改文件的属组

    ```bash
    # 只修改文件的属主
    # chown 用户名 文件名

    # 修改文件的属主和属组
    chown 用户名.组名 文件名
    # 没有指定组名，默认就是用户的主组
    chown 用户名. 文件名

    # 只修改文件的属组
    chown .组名 文件名
    chown :组名 文件名

    # 可以添加 -R 选项，表示递归修改
    ```

- **`chgrp` 命令**

  - `chgrp` 命令只能修改文件的属组

    ```bash
    chgrp 组名 文件名
    ```

## ✈️ 高级权限

### 🚄 高级权限有哪些

> 张三：file1 文件的属主和属组是张三
>
> 李四：使用 vim 编辑器修改张三的文件 file1

- **冒险位（SETUID）**
  - 指文件操作者（用户）临时拥有文件拥有者的权限
  - 一般针对的是命令或脚本文件
  - 用字母表示是 s 或 S，数学表示是 4
  - 设置方法：`chmod u+s 文件名` 或 `chmod 4xxx 文件名`
- **强制位（SETGID）**
  - 一般针对的是目录
    > 如果一个目录拥有强制位，那么任何用户在该目录里所创建的任何文件的属组都会继承该目录的属组。
  - 用字母表示是 s 或 S，数字表示是 2
  - 设置方法：`chmod g+s 文件名` 或 `chod 2xxx 文件名`
- **粘滞位（STICKY）**
  - 一般针对的是公共目录
    > 如果一个公共目录拥有粘滞位，那么该目录下的文件，只有 root 和文件的创建者可以删除，
    > 其他人只能自己管理自己（A 用户不能删除 B 用户创建的文件）
    >
    > 控制删除！针对公共目录，任何人都可以使用
  - 用字母表示是 t 或 T，数字表示是 1
  - 设置方法：`chmod o+t 文件名` 或 `chmod 1xxx 文件名`

### 🚄 高级权限设置

- **冒险位示例**

  - _需求：_ 给 vim 命令设置冒险位，目的是任何人拿 vim
    去修改文件都可以临时获取文件拥有者的权限

    ```bash
    # 在 root 用户下进行
    # 查看 vim 命令文件的位置
    which vim
    # 查看 vim 命令文件的详情
    ll /usr/bin/vim
    # 位 vim 命令文件设置冒险位
    chmod u+s /usr/bin/vim
    # 或
    chmod 4755 /usr/bin/vim
    # 查看 vim 命令文件的详情，看是否设置成功
    ll /usr/bin/vim

    # 测试验证，普通用户使用 vim 修改一个原本没有权限修改的文件
    # 查看 /etc/passwd 文件详情
    ll /etc/passwd
    # 切换到一个普通用户登入
    su - xxx
    # 在普通用户下使用 vim 修改 /etc/passwd 文件
    vim /etc/passwd
    # 验证是否可以修改成功，如果可以，说明普通用户 xxx 临时拥有了 /etc/passwd 文件拥有者的权限
    ```

- **强制位示例**

  - _需求：_ 给目录 dirA 设置一个强制位，测试是否任何人在该目录里创建的文件属组都是该目录的属组

    ```bash
    # 查看 dirA 目录的详情
    ll -d dirA
    # 给 dirA 目录增加强制位
    chmod g+s dirA
    # 给 dirA 目录设置权限，让其他人可以写入
    chmod o+w dirA
    # 查看 dirA 目录的详情
    ll -d dirA

    # 测试普通用户 xxx 在 dirA 目录里创建文件的属组是否是 dirA 的属组
    # 切换到 xxx 用户
    su - xxx
    # 创建文件 fileA
    # 查看 fileA 文件的详情
    ll dirA/fileA
    ```

- **粘滞位示例**

  - _需求：_ 创建一个公共目录 dirB，要求所有人都可以在该目录里创建、删除文件，
    但是只能自己管理自己，不能删除别人的文件

    ```bash
    # 创建目录 dirB
    mkdir dirB
    # 设置 dirB 目录的权限为 777
    chmod 777 dirB
    # 给 dirB 目录设置粘滞位
    chmod o+t dirB
    # 或者使用一条语句设置，一步到位
    chmod 1777 dirB
    # 查看 dirB 的详情
    ll -d dirB
    ```

## ✈️ 默认权限

### 🚄 什么是文件的默认权限

文件的默认权限也叫遮罩权限，是指用户创建文件后，文件天生就带有、不需要设置的权限

### 🚄 文件默认权限由谁控制

文件的默认权限由 `umask` 来控制

### 🚄 umask 如何控制文件的默认权限

- **临时控制**

  - _什么是临时控制？_

    - 临时控制指的是用命令 `umask` 做的临时设置，该设置只在当前终端当前进程中有效

    ```bash
    # 查看当前用户的 umask
    umask
    # 切换到用户 xxx
    su - xxx
    # 查看用户 xxx 的 umask
    umask
    # 注：管理员和普通用户的 umask 不同，就表示管理员和普通用户创建的文件的默认权限不同
    # 第 1 位数字表示高级权限，后面 3 位数字表示普通权限
    ```

  - _如何临时设置用户的 umask？_

    - 在 Linux 系统中，默认创建目录的最大权限是 `0777`，默认创建文件的最大权限是 `0666`

    ```bash
    # 临时设置用户的 umask 为 0007
    umask 0007
    # 此时当前终端当前用户的 umask 为 0007，那么当前终端当前用户所创建的目录和普通文件权限计算方法如下：
    # umask = 文件的最大权限 - 文件的默认权限
    # 此时创建目录的权限 = 0777 - umask = 0777 - 0007 = 0770 rwxrwx---
    # 此时创建普通文件的权限 = 0666 - umask = 0666 - 0007 = 0660 rw-rw----
    # 说明 1：权限用数字表示时没有负数，所以最小就是 0
    # 说明 2：默认权限规则遵循 Linux 系统中权限最小化原则，例如:
    # umask = 0003 则：
    # 新建目录权限 = 0777 - 0003 = 0774 rwxrwxr--
    # 新建文件权限 = 0666 - 0003 = 0663 rw-rw--wx 实际权限为 rw-rw-r--
    # umask = 0005 则：
    # 新建文件权限 = 0666 - 0005 = 0661 rw-rw---x 实际权限为：rw-rw--w-
    ```

- **永久控制**

  - _什么是永久设置?_
    - 永久设置是指通过修改配置文件设置，该设置对用户的所有终端所有进程都有效
  - _修改哪个配置文件呢？_

    1. **相关配置文件介绍**

       - _全局配置文件（针对所有用户所有进程）_

         - `/etc/profile` : 系统和用户的环境变量信息，当用户第一次登入时，该文件被读取
         - `/etc/bashrc` : 每个运行的 bash 信息（系统别名、函数以及默认权限的定义），当
           bash 被打开时，该文件被读取

       - _局部配置文件（针对某个特定用户以及用户的所有进程）_

         - `~/.bashrc` : 当前用户的 bash 信息，当用户登入和每次打开新的 shell 时，该文件被读取
         - `~/.bash_profile` : 当前用户的环境变量，当用户登入时，该文件被读取
         - `~/.bash_history` : 保存当前用户历史命令的文件
         - `~/.bash_logout` : 当前用户退出 bash 或者终端时，会首先执行该文件里的代码，然后再退出

    2. **如何永久设置用户的 umask？**

       - _针对所有用户生效_

         ```bash
         # 编辑 /etc/bashrc 文件
         vim /etc/bashrc
         # 在该文件的最后增加一行，内容为：umask 0007

         # 重新读取该配置文件使其马上生效
         source /etc/bashrc
         # 或
         . /etc/bashrc
         ```

       - _针对某个用户生效_

         ```bash
         # 比如，只针对 xxx 用户生效
         # 使用 xxx 用户登陆，编辑 xxx 用户下的 .bashrc 文件
         vim ~/.bashrc
         # 在该文件的最后增加一行，内容为：umask 0007

         # 重新读取该配置文件使其马上生效
         source ~/.bashrc
         # 或
         . ~/.bashrc
         ```

> - 配置文件分为全局配置和局部配置
> - 若全局配置和局部配有冲突，一般情况下以局部配置为准

## ✈️ ACL 访问控制策略

### 🚄 ACL 能做什么

- 可以作为其他权限控制的补充，以更加精细的方式来控制文件的权限
- 可以只针对某个用户在文件上有相应的权限
- 可以只针对多个用户或一个组里的所有用户在文件上有相应的权限

### 🚄 如何设置文件的 ACL 策略

- **设置 ACL 策略（`setfacl`）**

  - _常用选项_

    - `-m` : 修改或设置 ACL 策略
    - `-R` : 递归授权，对目录下已存在的目录或文件有 ACL 策略，但新建的文件没有
    - `-x` : 去掉某个用户或某个组的 ACL 策略
    - `-b` : 删除所有的 ACL 策略
    - `-d` : 默认 ACL 策略，只针对目录，该目录下新建的目录和文件都会继承 ACL 策略
    - `mask` : 定义除其他人和所有者外的最大权限

    ```bash
    # 给单个用户单独加权限
    setfacl -m u:用户:rwx /home/redhat/fileA
    # 给单个组单独加权限
    setfacl -m g:组名:rwx /home/redhat/fileA
    # 去掉某个用户的权限
    setfacl -x u:用户 /home/redhat/fileA
    # 去掉某个组的 ACL 策略
    setfacl -x g:组名 /home/redhat/fileA
    # 删除文件上所有的 ACL 策略
    setfacl -b /home/redhat/fileA
    # 针对单个用户给予可读可写权限
    setfacl -m u:用户:rw fileA
    # 针对单个组给予可读可写权限
    setfacl -m g:组名:rw fileA
    ```

- **查看 ACL 策略（`getfacl`）**
  - `getfacl 文件名`

# 🚀 RHEL8 的 Web 控制台管理系统

## ✈️ RHEL8 的 Web 控制台介绍

- **RHEL8 的 Web 控制台是什么？**
  - RHEL Web 控制台是一个基于 Web 的红帽企业版 Linux8 节目，
    用于管理和监视本地系统以及位于网络环境中的 Linux 服务器
  - RHEL8 Web 控制台是交互式服务器管理界面，通过浏览器与真实的 Linux 操作系统交互
- **Web 控制台可以做什么?**
  - 监控基本系统功能，例如硬件信息、时间配置、性能配置等
  - 检查系统日志文件
  - 管理网络接口和配置防火墙
  - 管理虚拟机
  - 管理用户账户
  - 监视和配置系统服务
  - 管理软件包
  - 配置 SELinux
  - 更新软件
  - 访问终端

## ✈️ 安装 Web 控制台

- **系统默认已经安装**

  ```bash
  # 查找软件源中相关的包或模块
  yum list|grep cockpit
  ```

- **设置是否开机自启**

  ```bash
  # 查看是否开机自启
  systemctl list-unit-files|grep cockpit
  # cockpit-motd.service    static
  # cockpit.service         static
  # cockpit.socket          disabled -->说明开机不会自启

  # 设置开机自启
  systemctl enable --now cockpit.socket

  # 查看是否开机自启
  systemctl list-unit-files|grep cockpit
  # cockpit-motd.service    static
  # cockpit.service         static
  # cockpit.socket          enable -->说明开机自启

  # 查看 cockpit 服务状态
  systemctl status cockpit.service
  # 手动启动 cockpit 服务
  systemctl start cockpit.service
  ```

- **设置防护墙策略（可选）**
- 如果系统防火墙是开启的，则需要执行以下操作，添加 cockpit 服务到防火墙以打开 9090 端口

  ```bash
  # 添加 cockpit 服务到防火墙以打开 9090 端口
  firewall-cmd --add-service=cockpit --permanent
  # 防火墙重新读取配置
  firewall-cmd --reload
  ```

## ✈️ 登入 Web 控制台

```bash
# 检查 9090 端口是否处于监听状态（root）
lsof -i :9090
```

- **登入账号说明**
  - Web 控制台账号认证文件位于 `/etc/pam.d/cockpit`
  - 允许使用系统上任何本地账户的用户名和密码登入

## ✈️ 用 Web 控制台对系统进行基本配置

# 🚀 主机名和静态 IP 配置

## ✈️ 主机名配置

- 使用 `hostnamectl` 命令进行主机名配置
- 通过 `hostnamectl` 命令修改的主机名会写入到 `/etc/hostname` 文件中，所以也可以直接修改这个文件
- 修改完成后，退出重新登入即可生效，不需要重启系统

```bash
# 修改主机名为 aaa.bbb.cn
hostnamectl set-hostname aaa.bbb.cn
# 查看修改是否写入文件
cat /etc/hostname
```

## ✈️ 静态 IP 配置

- **方法一：直接修改网卡配置文件**

  - _配置静态 IP 地址_

    ```bash
    # 进入网卡配置文件存放目录
    cd /etc/sysconfig/network-scripts/
    # 查看网卡配置文件列表
    ls
    # 查看某个网卡的配置（然后根据需要进行修改）
    cat ifcfg-ens160
    # TYPE=Ethernet                             # 以太网
    # BOOTPROTO=none                            # IP 获取方式，none 和 static 表示静态，dhcp 动态
    # NAME=ens160                               # 网卡名称
    # UUID=63b0b6ee-fbee-4b17-80be-e3b36ff27493 # 网卡 UUID，唯一标识
    # DEVICE=ens160                             # 网卡设备名
    # ONBOOT=yes                                # 激活网卡
    # IPADDR=192.168.159.100                    # IP 地址
    # PREFIX=24                                 # 子网掩码
    # NETMASK=255.255.255.0
    # GATEWAY=192.168.159.2                     # 网关
    # DNS1=8.8.8.8                              # dns服务器
    ```

  - _重载网卡配置文件_
    `nmcli connection reload ens160`
  - _激活网卡连接_
    `nmcli connection up ens160`

- **方法二：使用 `nmcli` 工具配置**

  - _查看网络连接情况_

    ```bash
    # 查看所有连接的网络信息
    nmcli connection show
    # 查看已经激活的网络连接信息
    nmcli connection show --active
    ```

  - _修改 ens160 网卡 IP 地址_

    ```bash
    nmcli connection modify ens160 ipv4.addresses 192.168.159.101/24
    ```

  - _增加、删除 IP 地址（子接口）_

    ```bash
    # 增加
    nmcli connection modify ens160 +ipv4.addresses 10.1.1.1/24
    # 删除
    nmcli connection modify ens160 -ipv4.addresses 10.1.1.1/24
    ```

  - _增加、删除 DNS_

    ```bash
    # 增加
    nmcli connection modify ens160 +ipv4.dns 8.8.8.8
    # 删除
    nmcli connection modify ens160 -ipv4.dns 8.8.8.8
    ```

  - _修改网络后需要重载配置文件并激活连接_

    ```bash
    # 重载网卡配置文件
    nmcli connection reload ens160
    # 激活网卡连接
    nmcli connection up ens160
    ```

- **方法三：使用 `nmtui` 文本图形工具进行配置**

  ```bash
  nmtui
  ```

> - 推荐使用直接修改配置文件的方式配置静态 IP
> - 从 RHEL8 以后要熟悉使用 `nmcli` 工具管理网络，因为 RHEL7 中的 `network.service`

# 🚀 软件包管理

## ✈️ Linux 系统中软件包的分类

- **软件包类型**
  - _二进制包_
    - 指的是已经编译好了的软件包，只要直接安装就可以使用
    - 不需要编译，直接下载安装即可
    - 需要根据自己计算机 CPU 以及操作系统去选择合适的包
    - 命名方式一般为：packagename-3.23-2.el6.x86_64.rpm
      - `packagename` : 软件包名字
      - `3.12` : 软件包版本
      - `el6` : 操作系统版本
      - `x86_64` : 计算机 CPU 架构和操作系统架构版本
      - `rpm` : rpm 包
  - _源码包_
    - 指的是程序员编写的原始的程序代码文件，不能够直接在计算机上运行
    - 需要进行编译，编译成二进制的软件包后，才可以安装使用
    - 一般可以在任何的计算机上安装使用
    - 命名方式：
      - `软件包名.tar.gz`
      - `软件包名.tar.bz2`
      - `软件包名.tar.xz`
      - `软件包名.zip`
  - _二进制源码包_
    - 是一个半成品，安装后不能直接使用
    - 需要使用 `rpmbuild` 工具重建以生成真正的 `rpm` 包或重建成源码包后才能安装使用
    - 命名方式一般为：
      - `xxx-1.2.34-1.el6.src.rpm`
- **常见的二进制包格式**

  | 系统平台                           | 包类型 | 工具          | 在线安装       |
  | :--------------------------------- | :----: | :------------ | :------------- |
  | RedHat/CentOS/Fedora/SUSE/openSUSE |  rpm   | rpm, rpmbuild | yum/dnf/zypper |
  | Debian/Ubuntu                      |  deb   | dpkg          | apt            |

- **二进制包和源码包的区别**

  | 软件包类型 | 是否需要编译 | 安装难易程度         | 可定制性 |
  | :--------- | :----------: | :------------------- | :------: |
  | 二进制包   |      否      | 易（直接安装）       |    差    |
  | 源码包     |      是      | 难（配置-编译-安装） |    好    |

## ✈️ Linux 系统中软件包的安装方式（Redhat 系列）

### 🚗 二进制包

- **使用 `rpm` 工具安装**
  1. 需要下载 rpm 包到本地
  2. 直接使用 `rpm` 工具安装
- **使用 `yum/dnf` 工具安装**
  - 配置软件仓库（里面存放了很多软件包，有网络仓库和本地仓库，一般以网络仓库为主）
  - 使用 `yum/dnf` 工具安装

### 🚗 源码包

1. **根据需求配置**

   - 定制功能

2. **编译**

   - 使用编译器编译成二进制的软件包

3. **安装**

   - 将软件包安装到指定的位置

4. **使用源码包安装的优点**

- 可以在任意平台上编译安装，编译出来的软件包非常适应所在的机器
- 可以在编译的时候通过配置，对某些功能进行定制，开启或关闭相应的功能

## ✈️ 二进制 rpm 包如何管理

### 🚗 如何获取 rpm 包

- **各大软件源仓库**
- **发行版光盘**
- **推荐网站**
  - [www.rpmfind.net](www.rpmfind.net)
  - [rpm.pbone.net](rpm.pbone.net)
- **相应软件的官方网站**

### 🚗 如何选择合适的 rpm 包

- **选择适合当前系统版本号的包**
  - 找不到合适的，才去尝试其他的系统版本号
  - el6 兼容 el5，但是 el5 无法安装 el6
- **选择适合当前计算机 CPU 架构的包**
  - `x86_64` : 只能安装在 64 位的系统上
  - `i386, i586, i686` : 可以安装在 32 位和 64 位的系统上
  - `noarch` : 软件包与硬件架构无关，可以通用
  - 32 位系统不能安装 64 位的包

> 建议不要跨大版本号去安装软件包，尽量使用当前系统版本自带的软件包

### 🚗 如何管理 rpm 包

#### 🏍️ `rpm` 管理工具

> - 可以进行 rpm 包的安装、卸载、升级、查询
> - 缺点：需要手动解决包的依赖关系，有时候非常麻烦

- **使用 `rpm` 工具安装 `rpm` 包**

  ```bash
  rpm -ivh 软件包
  # 注：软件包的名字必须写全，例如：xxx-x.xx.xx-xx.xxx.rpm
  ```

- **使用 `rpm` 工具卸载 `rpm` 包**

  ```bash
  rpm -e 软件包名
  # 注：卸载软件只需要软件包名字即可，例如：xxx
  ```

- **使用 `rpm` 工具升级 `rpm` 包**

  ```bash
  rpm -Uvh 软件包
  # 或
  rpm -Fvh 软件包
  # 选项说明：
  #   -v : 输出详细信息
  #   -h : 打印散列标记，一般和 -v 一起使用
  #   -U : 升级软件包，如果该软件包没有安装，会自动安装
  #   -F : 升级软件包，如果该软件包没有安装，不会自动安装
  ```

- **使用 `rpm` 工具查看已经安装的 `rpm` 包信息**

  ```bash
  # 查看已经安装软件包所包含的文件列表
  rpm -ql 软件包名
  # 查看未安装的 rpm 包里包含的文件列表
  rpm -qlp 软件包(xxx.rpm)
  # 查看已经安装的所有 rpm 包
  rpm -qa 软件包名
  # 搜索已经安装的 rpm 包
  rpm -qa|grep 软件包名
  # 查看已经安装软件包的文档列表
  rpm -qd 软件包名
  # 查看已经安装软件包的配置文件
  rpm -qc 软件包名
  # 查看已经安装软件包的详细信息
  rpm -qi 软件包名
  # 查看指定文件来自哪个 rpm 包
  rpm -qf 文件名
  ```

- **`rpm` 工具其他常见的安装、卸载选项**

  - _`--force` : 强制_

    ```bash
    # 强制安装软件包
    rpm -ivh 软件包 --force
    # 强制卸载软件包
    rpm -e 软件包名 --force
    ```

  - _`--nodeps` : 忽略依赖关系_

    ```bash
    # 安装时忽略依赖关系
    rpm -ivh 软件包 --nodeps
    # 卸载时忽略依赖关系
    rpm -e 软件包 --nodeps
    ```

  - _其他_

    ```bash
    # 导入公钥用于检查 rpm 文件的签名
    rpm --import key_file
    # 检查 rpm 包的签名
    rpm --checksig package.rpm
    ```

#### 🏍️ `yum(dnf)` 管理工具

> - **优点：** 能够自动解决包的依赖关系
> - **核心：** 需要有一个软件仓库（软件仓库指的是用来存放软件包和软件包之间依赖关系的地方）
>   - _需要有软件仓库_
>     - 本地（本地 yum 源）
>     - 远程（网络 yum 源，网络必须可连接）
>   - _需要告诉 yum 工具到哪个仓库找软件包_
>     - 默认有个目录存放了 xxx.repo 文件（定义了去哪个仓库找软件包）

- **配置本地 yum 源**

  - **_本地仓库的分类_**
    - _BaseOS 存储库_
      - BaseOS 存储库旨在提供一套核心的底层操作系统的功能，是基础软件安装库
    - _AppStream 存储库_
      - AppStream 存储库中包括额外的用户空间应用程序、运行时语言和数据库，
        以支持不同的工作负载和用例
      - AppStream 存储库中的内容有两种格式：一般的 rpm 格式和被称之为模块的 rpm 扩展格式
  - **_配置本地仓库_**

    1. _挂载镜像到本地系统_

       ```bash
       mount -o ro /dev/sr0 /mnt
       # 列出 BaseOS 和 AppStream 的内容如下说明仓库已经准备好了
       ls /mnt/BaseOS/
       # Packages repodata
       ls /mnt/AppStream/
       # Packages repodata
       ```

    2. _修改配置文件以指定本地存储库_

       1. 创建配置文件

          ```bash
          # 进入 yum 仓库配置文件目录
          cd /etc/yum.repos.d/
          # 创建本地 yum 仓库配置文件
          touch local.repo
          ```

       2. 将如下内容写入配置文件

          ```bash
          [BaseOS_local]
          name=BaseOS_local
          baseurl=file:///mnt/BaseOS
          gpgcheck=0
          enabled=

          [AppStream_local]
          name=AppStream_local
          baseurl=file:///mnt/AppStream
          enabled=1
          gpgcheck=0
          ```

    3. _查看是否成功_

       ```bash
       # 清空 yum 缓存
       yum clean all
       # 创建 yum 缓存
       yum makecache
       # 查看仓库列表
       yum repolist
       ```

- **_`yum(dnf)` 工具的使用_**

  - _安装软件包_

    ```bash
    yum -y install 软件包1 软件包2
    yum -y groupinstall "包组名"
    # 注：-y 表示直接安装，不询问
    #     包组里包含很多软件包，通常是一系列软件包的集合
    ```

  - _卸载软件包_

    ```bash
    yum -y remove 软件包
    yum -y groupremove "包组名"
    ```

  - _升级 rpm 包_

    ```bash
    yum update 软件包名
    ```
